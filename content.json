{"pages":[],"posts":[{"title":"Timeline for Alexis Blog","text":"2018/09/09 First Created.2019/01/01 About Page Added.","link":"/2018/09/09/timeline/timeline/"},{"title":"Java ClassLoader","text":"什么是ClassLoaderJava ClassLoader是一个非常重要但是在平时开发过程中很少直接用到的类，从JDK源码中可以看出ClassLoader是一个抽象类；我们都知道Java程序是跑在JVM上的，当我们编译一个Java类的时候，JVM会将我们写的Java程序转换成以.class作为后缀的字节码程序，这类程序是和平台与机器无关的。当我们尝试使用这个类的时候，ClassLoader就将对应的类加载到内存中。 ClassLoader的类型在Java中，有三种内置的ClassLoader： Bootstrap Class Loader - 负责加载JDK内部的类，即位于$JAVA_HOME/jre/lib目录下的jar包中的类，如rt.jar， charsets.jar等，我们平时常用的java.lang.* 包中的类均是由Bootstrap Class Loader加载的。 Extensions Class Loader - 负责加载$JAVA_HOME/jre/lib/ext目录下的jar包中的类。 System Class Loader - 负责加载当前classpath中的Java类，classpath一般是我们在启动Java程序时通过-cp或者-classpath来指定的 类的加载时机和加载方式（父类委托机制）在以下两种情况下类会被加载： 使用new关键字申请类的实例时，例如：MyClass mc = new MyClass() 代码中使用类的静态引用时，例如：System.out 从上面的图上可以看出，类加载器是采用继承结构的。第一个类是通过我们程序中声明的静态main方法static main()来加载的。下面所有类的加载都是通过已经加载的类来加载的。类加载过程遵循以下原则： 调用findLoadedClass()方法检查要加载的类是否已经被加载了 如果没有被加载，请求它的父类加载器加载请求的类 如果父类加载器无法加载，则尝试自己加载 ClassLoader代码示例：1234567891011121314/** * @author Alexis.Yang * @descriptioin * @date 2019-06-17 20:49 * @copyright www.embracesource.com */public class ClassLoaderExample &#123; public static void main(String[] args) &#123; System.out.println(\"class loader for HashMap: \" + HashMap.class.getClassLoader()); System.out.println(\"class loader for ECPublicKeyImpl\" + sun.security.ec.ECPublicKeyImpl.class.getClassLoader()); System.out.println(\"class loader for this class: \" + ClassLoaderExample.class.getClassLoader()); &#125;&#125; 这段代码的返回结果如下：123class loader for HashMap: nullclass loader for ECPublicKeyImplsun.misc.Launcher$ExtClassLoader@355da254class loader for this class: sun.misc.Launcher$AppClassLoader@18b4aac2 我们可以看出：HashMap的classLoader是null，代表这是由Bootstrap Class Loader来加载的，Bootstrap Class Loader是C++实现的，用Java代码无法获取到，所以得到null；ECPublicKeyImpl是ExtClassLoader加载的，这个类来源于sunec.jar包；而我们的当前类是AppClassLoader或称为System ClassLoader加载的，因为当前类在ClassPath中。 注意父类加载器加载的类对象对子类加载器可见，兄弟类加载器加载的类对象互相不可见。 静态加载VS动态加载 静态类加载通过new关键字完成； 动态类加载通过运行时类型判断，即反射完成； 动态类加载可以通过以下方法完成：getClass(); getName(); getDeclaredFields(); 可以通过调用类名.forName()来获取类的实例；该方法会将类实例加载到当前类的内存中；Java中的静态加载和动态加载 使用new关键字创建对象和实例称为静态类加载。类定义和对象实例化在编译期完成； 使用Class.forName()方法加载类为动态类加载，当在编译器不知道类的名字的时候动态类加载即完成； loadClass和Class.forName的区别loadClass只加载类并不初始化对象实例，而Class.forName在加载类后初始化对象实例。例如，若使用ClassLoader.loadClass加载JDBC驱动的时候，驱动不会被注册，JDBC也无法使用；而java.lang.Class.forName(String className)返回与对象关联的对象实例或者String类型的接口名；如果类找不到则抛出ClassNotFoundException异常。Class.forName的用法如下：123456789101112131415161718192021222324/** * @author Alexis.Yang * @descriptioin * @date 2019-06-17 20:15 * @copyright www.ychenchen.com */public class ClassForNameExample &#123; public static void main(String[] args) &#123; try &#123; Class&lt;?&gt; clazz = Class.forName(\"java.math.BigDecimal\"); System.out.println(\"name = \" + clazz.getName()); System.out.println(\"package = \" + clazz.getPackage()); Constructor&lt;?&gt;[] constructors = clazz.getConstructors(); Field[] declaredFields = clazz.getDeclaredFields(); Method[] declaredMethods = clazz.getDeclaredMethods(); for (Field declaredField: declaredFields) &#123; System.out.println(declaredField.getName()); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 可以看到，通过Class.forName, 类加载了且被实例化了，我们可以获取到类定义的相关信息：1234567891011121314name = java.math.BigDecimalpackage = package java.math, Java Platform API Specification, version 1.8intValscaleprecisionstringCacheINFLATEDINFLATED_BIGINTintCompactMAX_COMPACT_DIGITSserialVersionUIDthreadLocalStringBuilderHelperzeroThroughTen... 参考文档https://www.journaldev.com/349/java-classloader https://javatutorial.net/java-class-loaders-explained https://www.careerride.com/Java-Static-Dynamic-Class.aspx","link":"/2019/06/03/java/jvm/classloader/"}],"tags":[{"name":"timeline","slug":"timeline","link":"/tags/timeline/"},{"name":"java jvm","slug":"java-jvm","link":"/tags/java-jvm/"}],"categories":[{"name":"timeline","slug":"timeline","link":"/categories/timeline/"},{"name":"jvm","slug":"jvm","link":"/categories/jvm/"}]}