{"pages":[],"posts":[{"title":"01-intro_to_stateful_stream_processing","text":"1. Apache Flink是什么? — Architecture 官网定义： Apache Flink is a framework and distributed processing engine for stateful computations over unbounded and bounded data streams. Flink has been designed to run in all common cluster environments, perform computations at in-memory speed and at any scale. 其他定义： Apache Flink is a distributed stream processor with intuitive and expressive APIs to implement stateful stream processing applications. It efficiently runs such applications at large scale in a fault-tolerant manner. 2. 传统的数据处理架构传统的数据处理架构一般分为两种类型：transactional processing and analytical processing. transactional processing在传统的关系型事务处理架构下，整个系统被划分为数据处理层（计算层，部署各种应用）和数据存储层（关系型数据库）：在这种架构下，当事件被处理的时候，应用从数据库中读取它的状态或者更新关系型数据库的状态。通常，一个数据库需要同时为多个应用提供服务，那么，当需要扩展关系型数据库或者修改Schema、表名等的时候就要格外小心了。针对这个问题，出现了微服务设计模式，微服务遵循Linux的一次只做一件事儿，且要把这件事儿做好的设计理念，在微服务架构下，各个服务之间是严格解耦合的，应用之间通过接口进行通信，每个服务可以采用不同的技术栈（不同的编程语言，不同的数据存储）来实现。下图展示了一个微服务的一般架构： Analytical Processing和事务型处理应用不同的是，分析型架构一般将数据存储在数据仓库中，这个过程一般是通过ETL工具将数据从日志或者关系型数据库转存到数据仓库。基于数据仓库的查询一般有两类：一类是用来做报表统计，一类是用来做ad-hoc queries（即席查询）。这两类都是基于数据仓库做批次查询。 3. Stateful Stream Processing(有状态数据流处理)有状态数据流处理用来处理那种无界的数据流，先解释一下它是如何执行的：任何处理流式数据且不是来一条就处理一条的应用都需要是stateful的，通过state来保存和获取中间数据。当应用产生一条数据的时候，它可以执行任意从state中读取数据或者将数据写入到state的操作。state可以保存在很多地方：程序变量，本地文本文件，嵌入式的或者外部的数据库等。Apache Flink将状态保存到本地内存或者嵌入式数据库中，由于Flink是一个分布式系统，为了防止机器故障或者应用故障造成本地状态丢失，Flink周期性的将应用state的checkpoint写入到远端的持久化存储中。 有状态流式处理是非常灵活的，也有很多应用场景，下面我们来讨论三个： 4. REAL-WORLD STREAMING USE-CASES4.1 Event-Driven Applications事件驱动应用典型的应用场景包括： 实时推荐（e.g. 消费者浏览购物网站时实时推荐产品） 模式识别和复杂事件处理（e.g. 信用卡交易欺诈检测） 异常检测（e.g. 检测针对计算机网络的攻击尝试） 事件驱动应用是微服务架构的进化，它们通过事件日志而不是Rest接口进行通信。它把应用产生的数据作为本地状态（local state）保存，而不是写入外部存储中。下图是一个典型的事件驱动流式应用的服务架构：上图中应用是通过事件日志进行连接的，前面的应用将输出发送给event log, 后续应用消费event log. 每个应用都可以是stateful的，且都可以本地化存储自己的state而无需访问外部数据库。应用本身也都可以单独扩展。 4.2 Data Pipelines现在的软件架构往往会将一份数据分别放到多种存储中，这种情况下，保持数据的一致性是非常重要的。通常采用ETL定期完成这类工作，但时效性很难保证。因此，可以采用event log来分发更新。所有的更新被写入和分发到event log中，消费端将更新合并到目标存储中。低延迟的摄取、转换、写入数据是有状态流式处理的另一个应用。这类应用被称作data pipeline. Data pipeline必须能在短时间内处理大量的数据。Data pipeline要能够支持不同的数据源和目标源，所有这些，Flink都可以做到。 4.3 Streaming AnalyticsStreaming analytics应用通常用于以下场景： 监控电话网络的质量 分析用户在电话应用中的行为 用户实时数据的即席查询","link":"/2019/09/20/flink/01-intro-to-stateful-stream-processing/"},{"title":"Timeline for Alexis Blog","text":"2018/09/09 First Created.2019/01/01 About Page Added.","link":"/2018/09/09/timeline/timeline/"},{"title":"Java ClassLoader","text":"什么是ClassLoaderJava ClassLoader是一个非常重要但是在平时开发过程中很少直接用到的类，从JDK源码中可以看出ClassLoader是一个抽象类；我们都知道Java程序是跑在JVM上的，当我们编译一个Java类的时候，JVM会将我们写的Java程序转换成以.class作为后缀的字节码程序，这类程序是和平台与机器无关的。当我们尝试使用这个类的时候，ClassLoader就将对应的类加载到内存中。 ClassLoader的类型在Java中，有三种内置的ClassLoader： Bootstrap Class Loader - 负责加载JDK内部的类，即位于$JAVA_HOME/jre/lib目录下的jar包中的类，如rt.jar， charsets.jar等，我们平时常用的java.lang.* 包中的类均是由Bootstrap Class Loader加载的。 Extensions Class Loader - 负责加载$JAVA_HOME/jre/lib/ext目录下的jar包中的类。 System Class Loader - 负责加载当前classpath中的Java类，classpath一般是我们在启动Java程序时通过-cp或者-classpath来指定的 类的加载时机和加载方式（父类委托机制）在以下两种情况下类会被加载： 使用new关键字申请类的实例时，例如：MyClass mc = new MyClass() 代码中使用类的静态引用时，例如：System.out 从上面的图上可以看出，类加载器是采用继承结构的。第一个类是通过我们程序中声明的静态main方法static main()来加载的。下面所有类的加载都是通过已经加载的类来加载的。类加载过程遵循以下原则： 调用findLoadedClass()方法检查要加载的类是否已经被加载了 如果没有被加载，请求它的父类加载器加载请求的类 如果父类加载器无法加载，则尝试自己加载 ClassLoader代码示例：1234567891011121314/** * @author Alexis.Yang * @descriptioin * @date 2019-06-17 20:49 * @copyright www.embracesource.com */public class ClassLoaderExample &#123; public static void main(String[] args) &#123; System.out.println(\"class loader for HashMap: \" + HashMap.class.getClassLoader()); System.out.println(\"class loader for ECPublicKeyImpl\" + sun.security.ec.ECPublicKeyImpl.class.getClassLoader()); System.out.println(\"class loader for this class: \" + ClassLoaderExample.class.getClassLoader()); &#125;&#125; 这段代码的返回结果如下：123class loader for HashMap: nullclass loader for ECPublicKeyImplsun.misc.Launcher$ExtClassLoader@355da254class loader for this class: sun.misc.Launcher$AppClassLoader@18b4aac2 我们可以看出：HashMap的classLoader是null，代表这是由Bootstrap Class Loader来加载的，Bootstrap Class Loader是C++实现的，用Java代码无法获取到，所以得到null；ECPublicKeyImpl是ExtClassLoader加载的，这个类来源于sunec.jar包；而我们的当前类是AppClassLoader或称为System ClassLoader加载的，因为当前类在ClassPath中。 注意父类加载器加载的类对象对子类加载器可见，兄弟类加载器加载的类对象互相不可见。 静态加载VS动态加载 静态类加载通过new关键字完成； 动态类加载通过运行时类型判断，即反射完成； 动态类加载可以通过以下方法完成：getClass(); getName(); getDeclaredFields(); 可以通过调用类名.forName()来获取类的实例；该方法会将类实例加载到当前类的内存中；Java中的静态加载和动态加载 使用new关键字创建对象和实例称为静态类加载。类定义和对象实例化在编译期完成； 使用Class.forName()方法加载类为动态类加载，当在编译器不知道类的名字的时候动态类加载即完成； loadClass和Class.forName的区别loadClass只加载类并不初始化对象实例，而Class.forName在加载类后初始化对象实例。例如，若使用ClassLoader.loadClass加载JDBC驱动的时候，驱动不会被注册，JDBC也无法使用；而java.lang.Class.forName(String className)返回与对象关联的对象实例或者String类型的接口名；如果类找不到则抛出ClassNotFoundException异常。Class.forName的用法如下：123456789101112131415161718192021222324/** * @author Alexis.Yang * @descriptioin * @date 2019-06-17 20:15 * @copyright www.ychenchen.com */public class ClassForNameExample &#123; public static void main(String[] args) &#123; try &#123; Class&lt;?&gt; clazz = Class.forName(\"java.math.BigDecimal\"); System.out.println(\"name = \" + clazz.getName()); System.out.println(\"package = \" + clazz.getPackage()); Constructor&lt;?&gt;[] constructors = clazz.getConstructors(); Field[] declaredFields = clazz.getDeclaredFields(); Method[] declaredMethods = clazz.getDeclaredMethods(); for (Field declaredField: declaredFields) &#123; System.out.println(declaredField.getName()); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 可以看到，通过Class.forName, 类加载了且被实例化了，我们可以获取到类定义的相关信息：1234567891011121314name = java.math.BigDecimalpackage = package java.math, Java Platform API Specification, version 1.8intValscaleprecisionstringCacheINFLATEDINFLATED_BIGINTintCompactMAX_COMPACT_DIGITSserialVersionUIDthreadLocalStringBuilderHelperzeroThroughTen... 参考文档https://www.journaldev.com/349/java-classloader https://javatutorial.net/java-class-loaders-explained https://www.careerride.com/Java-Static-Dynamic-Class.aspx","link":"/2019/06/03/spark/classloader/"},{"title":"Introduction to stateful stream processing.","text":"1. Apache Flink是什么? — Architecture 官网定义： Apache Flink is a framework and distributed processing engine for stateful computations over unbounded and bounded data streams. Flink has been designed to run in all common cluster environments, perform computations at in-memory speed and at any scale. 其他定义： Apache Flink is a distributed stream processor with intuitive and expressive APIs to implement stateful stream processing applications. It efficiently runs such applications at large scale in a fault-tolerant manner. 2. 传统的数据处理架构传统的数据处理架构一般分为两种类型：transactional processing and analytical processing. transactional processing在传统的关系型事务处理架构下，整个系统被划分为数据处理层（计算层，部署各种应用）和数据存储层（关系型数据库）：在这种架构下，当事件被处理的时候，应用从数据库中读取它的状态或者更新关系型数据库的状态。通常，一个数据库需要同时为多个应用提供服务，那么，当需要扩展关系型数据库或者修改Schema、表名等的时候就要格外小心了。针对这个问题，出现了微服务设计模式，微服务遵循Linux的一次只做一件事儿，且要把这件事儿做好的设计理念，在微服务架构下，各个服务之间是严格解耦合的，应用之间通过接口进行通信，每个服务可以采用不同的技术栈（不同的编程语言，不同的数据存储）来实现。下图展示了一个微服务的一般架构： Analytical Processing和事务型处理应用不同的是，分析型架构一般将数据存储在数据仓库中，这个过程一般是通过ETL工具将数据从日志或者关系型数据库转存到数据仓库。基于数据仓库的查询一般有两类：一类是用来做报表统计，一类是用来做ad-hoc queries（即席查询）。这两类都是基于数据仓库做批次查询。 3. Stateful Stream Processing(有状态数据流处理)有状态数据流处理用来处理那种无界的数据流，先解释一下它是如何执行的：任何处理流式数据且不是来一条就处理一条的应用都需要是stateful的，通过state来保存和获取中间数据。当应用产生一条数据的时候，它可以执行任意从state中读取数据或者将数据写入到state的操作。state可以保存在很多地方：程序变量，本地文本文件，嵌入式的或者外部的数据库等。Apache Flink将状态保存到本地内存或者嵌入式数据库中，由于Flink是一个分布式系统，为了防止机器故障或者应用故障造成本地状态丢失，Flink周期性的将应用state的checkpoint写入到远端的持久化存储中。 有状态流式处理是非常灵活的，也有很多应用场景，下面我们来讨论三个： 4. REAL-WORLD STREAMING USE-CASES4.1 Event-Driven Applications事件驱动应用典型的应用场景包括： 实时推荐（e.g. 消费者浏览购物网站时实时推荐产品） 模式识别和复杂事件处理（e.g. 信用卡交易欺诈检测） 异常检测（e.g. 检测针对计算机网络的攻击尝试） 事件驱动应用是微服务架构的进化，它们通过事件日志而不是Rest接口进行通信。它把应用产生的数据作为本地状态（local state）保存，而不是写入外部存储中。下图是一个典型的事件驱动流式应用的服务架构：上图中应用是通过事件日志进行连接的，前面的应用将输出发送给event log, 后续应用消费event log. 每个应用都可以是stateful的，且都可以本地化存储自己的state而无需访问外部数据库。应用本身也都可以单独扩展。 4.2 Data Pipelines现在的软件架构往往会将一份数据分别放到多种存储中，这种情况下，保持数据的一致性是非常重要的。通常采用ETL定期完成这类工作，但时效性很难保证。因此，可以采用event log来分发更新。所有的更新被写入和分发到event log中，消费端将更新合并到目标存储中。低延迟的摄取、转换、写入数据是有状态流式处理的另一个应用。这类应用被称作data pipeline. Data pipeline必须能在短时间内处理大量的数据。Data pipeline要能够支持不同的数据源和目标源，所有这些，Flink都可以做到。 4.3 Streaming AnalyticsStreaming analytics应用通常用于以下场景： 监控电话网络的质量 分析用户在电话应用中的行为 用户实时数据的即席查询","link":"/2019/09/20/flink/intro_to_stateful_stream_processing/"},{"title":"Java ClassLoader","text":"什么是ClassLoaderJava ClassLoader是一个非常重要但是在平时开发过程中很少直接用到的类，从JDK源码中可以看出ClassLoader是一个抽象类；我们都知道Java程序是跑在JVM上的，当我们编译一个Java类的时候，JVM会将我们写的Java程序转换成以.class作为后缀的字节码程序，这类程序是和平台与机器无关的。当我们尝试使用这个类的时候，ClassLoader就将对应的类加载到内存中。 ClassLoader的类型在Java中，有三种内置的ClassLoader： Bootstrap Class Loader - 负责加载JDK内部的类，即位于$JAVA_HOME/jre/lib目录下的jar包中的类，如rt.jar， charsets.jar等，我们平时常用的java.lang.* 包中的类均是由Bootstrap Class Loader加载的。 Extensions Class Loader - 负责加载$JAVA_HOME/jre/lib/ext目录下的jar包中的类。 System Class Loader - 负责加载当前classpath中的Java类，classpath一般是我们在启动Java程序时通过-cp或者-classpath来指定的 类的加载时机和加载方式（父类委托机制）在以下两种情况下类会被加载： 使用new关键字申请类的实例时，例如：MyClass mc = new MyClass() 代码中使用类的静态引用时，例如：System.out 从上面的图上可以看出，类加载器是采用继承结构的。第一个类是通过我们程序中声明的静态main方法static main()来加载的。下面所有类的加载都是通过已经加载的类来加载的。类加载过程遵循以下原则： 调用findLoadedClass()方法检查要加载的类是否已经被加载了 如果没有被加载，请求它的父类加载器加载请求的类 如果父类加载器无法加载，则尝试自己加载 ClassLoader代码示例：1234567891011121314/** * @author Alexis.Yang * @descriptioin * @date 2019-06-17 20:49 * @copyright www.embracesource.com */public class ClassLoaderExample &#123; public static void main(String[] args) &#123; System.out.println(\"class loader for HashMap: \" + HashMap.class.getClassLoader()); System.out.println(\"class loader for ECPublicKeyImpl\" + sun.security.ec.ECPublicKeyImpl.class.getClassLoader()); System.out.println(\"class loader for this class: \" + ClassLoaderExample.class.getClassLoader()); &#125;&#125; 这段代码的返回结果如下：123class loader for HashMap: nullclass loader for ECPublicKeyImplsun.misc.Launcher$ExtClassLoader@355da254class loader for this class: sun.misc.Launcher$AppClassLoader@18b4aac2 我们可以看出：HashMap的classLoader是null，代表这是由Bootstrap Class Loader来加载的，Bootstrap Class Loader是C++实现的，用Java代码无法获取到，所以得到null；ECPublicKeyImpl是ExtClassLoader加载的，这个类来源于sunec.jar包；而我们的当前类是AppClassLoader或称为System ClassLoader加载的，因为当前类在ClassPath中。 注意父类加载器加载的类对象对子类加载器可见，兄弟类加载器加载的类对象互相不可见。 静态加载VS动态加载 静态类加载通过new关键字完成； 动态类加载通过运行时类型判断，即反射完成； 动态类加载可以通过以下方法完成：getClass(); getName(); getDeclaredFields(); 可以通过调用类名.forName()来获取类的实例；该方法会将类实例加载到当前类的内存中；Java中的静态加载和动态加载 使用new关键字创建对象和实例称为静态类加载。类定义和对象实例化在编译期完成； 使用Class.forName()方法加载类为动态类加载，当在编译器不知道类的名字的时候动态类加载即完成； loadClass和Class.forName的区别loadClass只加载类并不初始化对象实例，而Class.forName在加载类后初始化对象实例。例如，若使用ClassLoader.loadClass加载JDBC驱动的时候，驱动不会被注册，JDBC也无法使用；而java.lang.Class.forName(String className)返回与对象关联的对象实例或者String类型的接口名；如果类找不到则抛出ClassNotFoundException异常。Class.forName的用法如下：123456789101112131415161718192021222324/** * @author Alexis.Yang * @descriptioin * @date 2019-06-17 20:15 * @copyright www.ychenchen.com */public class ClassForNameExample &#123; public static void main(String[] args) &#123; try &#123; Class&lt;?&gt; clazz = Class.forName(\"java.math.BigDecimal\"); System.out.println(\"name = \" + clazz.getName()); System.out.println(\"package = \" + clazz.getPackage()); Constructor&lt;?&gt;[] constructors = clazz.getConstructors(); Field[] declaredFields = clazz.getDeclaredFields(); Method[] declaredMethods = clazz.getDeclaredMethods(); for (Field declaredField: declaredFields) &#123; System.out.println(declaredField.getName()); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 可以看到，通过Class.forName, 类加载了且被实例化了，我们可以获取到类定义的相关信息：1234567891011121314name = java.math.BigDecimalpackage = package java.math, Java Platform API Specification, version 1.8intValscaleprecisionstringCacheINFLATEDINFLATED_BIGINTintCompactMAX_COMPACT_DIGITSserialVersionUIDthreadLocalStringBuilderHelperzeroThroughTen... 参考文档https://www.journaldev.com/349/java-classloader https://javatutorial.net/java-class-loaders-explained https://www.careerride.com/Java-Static-Dynamic-Class.aspx","link":"/2019/06/03/java/jvm/classloader/"}],"tags":[{"name":"flink","slug":"flink","link":"/tags/flink/"},{"name":"timeline","slug":"timeline","link":"/tags/timeline/"},{"name":"java jvm","slug":"java-jvm","link":"/tags/java-jvm/"}],"categories":[{"name":"flink","slug":"flink","link":"/categories/flink/"},{"name":"timeline","slug":"timeline","link":"/categories/timeline/"},{"name":"jvm","slug":"jvm","link":"/categories/jvm/"}]}