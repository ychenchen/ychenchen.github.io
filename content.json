{"pages":[],"posts":[{"title":"Timeline for Alexis Blog","text":"2018/09/09 First Created.2019/01/01 About Page Added.","link":"/2018/09/09/timeline/timeline/"},{"title":"Java ClassLoader","text":"什么是ClassLoaderJava ClassLoader是一个非常重要但是在平时开发过程中很少直接用到的类，从JDK源码中可以看出ClassLoader是一个抽象类；我们都知道Java程序是跑在JVM上的，当我们编译一个Java类的时候，JVM会将我们写的Java程序转换成以.class作为后缀的字节码程序，这类程序是和平台与机器无关的。当我们尝试使用这个类的时候，ClassLoader就将对应的类加载到内存中。 ClassLoader的类型在Java中，有三种内置的ClassLoader： Bootstrap Class Loader - 负责加载JDK内部的类，即位于$JAVA_HOME/jre/lib目录下的jar包中的类，如rt.jar， charsets.jar等，我们平时常用的java.lang.* 包中的类均是由Bootstrap Class Loader加载的。 Extensions Class Loader - 负责加载$JAVA_HOME/jre/lib/ext目录下的jar包中的类。 System Class Loader - 负责加载当前classpath中的Java类，classpath一般是我们在启动Java程序时通过-cp或者-classpath来指定的 类的加载时机和加载方式（父类委托机制）在以下两种情况下类会被加载： 使用new关键字申请类的实例时，例如：MyClass mc = new MyClass() 代码中使用类的静态引用是，例如：System.out 从上面的图上可以看出，类加载器是采用继承结构的。第一个类是通过我们程序中声明的静态main方法static main()来加载的。下面所有类的加载都是通过已经加载的类来加载的。类加载过程遵循以下原则： 检查要加载的类是否已经被加载了 如果没有被加载，请求它的父类加载器加载请求的类 如果父类加载器无法加载，则尝试自己加载","link":"/2019/06/03/java/jvm/classloader/"}],"tags":[{"name":"timeline","slug":"timeline","link":"/tags/timeline/"},{"name":"java jvm","slug":"java-jvm","link":"/tags/java-jvm/"}],"categories":[{"name":"timeline","slug":"timeline","link":"/categories/timeline/"},{"name":"jvm","slug":"jvm","link":"/categories/jvm/"}]}